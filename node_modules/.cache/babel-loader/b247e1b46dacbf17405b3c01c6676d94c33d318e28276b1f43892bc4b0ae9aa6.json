{"ast":null,"code":"// src/eventBus.ts\nvar _on = (eventToHandlersMap, latestPayloadMap, event, handler, opts) => {\n  const {\n    notify\n  } = opts || {};\n  let handlers = eventToHandlersMap.get(event);\n  if (!handlers) {\n    handlers = [];\n    eventToHandlersMap.set(event, handlers);\n  }\n  handlers.push(handler);\n  if (notify && latestPayloadMap.has(event)) {\n    handler(latestPayloadMap.get(event));\n  }\n};\nvar _dispatch = (eventToHandlersMap, event, payload) => (eventToHandlersMap.get(event) || []).map(h => h(payload));\nvar _off = (eventToHandlersMap, event, handler) => {\n  const handlers = eventToHandlersMap.get(event);\n  if (handlers) {\n    if (handler) {\n      handlers.splice(handlers.indexOf(handler) >>> 0, 1);\n    } else {\n      eventToHandlersMap.set(event, []);\n    }\n  }\n};\nvar createEventBus = () => {\n  const eventToHandlersMap = /* @__PURE__ */new Map();\n  const latestPayloadMap = /* @__PURE__ */new Map();\n  const eventToPredispatchHandlersMap = /* @__PURE__ */new Map();\n  const emit = (event, payload) => {\n    latestPayloadMap.set(event, payload);\n    _dispatch(eventToPredispatchHandlersMap, event, payload);\n    _dispatch(eventToHandlersMap, event, payload);\n  };\n  return {\n    // Subscribe to an event\n    on: (...args) => _on(eventToHandlersMap, latestPayloadMap, ...args),\n    // Subscribe to an event with priority\n    // Registered handlers with `prioritizedOn` will be called before handlers registered with `on`\n    prioritizedOn: (...args) => _on(eventToPredispatchHandlersMap, latestPayloadMap, ...args),\n    // Dispatch an event\n    emit,\n    // Unsubscribe from an event\n    off: (...args) => _off(eventToHandlersMap, ...args),\n    // Unsubscribe from an event with priority\n    // Unsubscribes handlers only registered with `prioritizedOn`\n    prioritizedOff: (...args) => _off(eventToPredispatchHandlersMap, ...args),\n    // Internal utilities\n    internal: {\n      retrieveListeners: event => eventToHandlersMap.get(event) || []\n    }\n  };\n};\nexport { createEventBus };","map":{"version":3,"names":["_on","eventToHandlersMap","latestPayloadMap","event","handler","opts","notify","handlers","get","set","push","has","_dispatch","payload","map","h","_off","splice","indexOf","createEventBus","Map","eventToPredispatchHandlersMap","emit","on","args","prioritizedOn","off","prioritizedOff","internal","retrieveListeners"],"sources":["D:\\Ripple Media Office work\\React\\wisdomwithin-clerk-new\\node_modules\\@clerk\\shared\\src\\eventBus.ts"],"sourcesContent":["/**\n * Type definition for event handler functions\n */\ntype EventHandler<Events extends Record<string, unknown>, Key extends keyof Events> = (payload: Events[Key]) => void;\n\n/**\n * @interface\n * Strongly-typed event bus interface that enables type-safe publish/subscribe patterns\n */\ntype EventBus<Events extends Record<string, unknown>> = {\n  /**\n   * Subscribe to an event\n   *\n   * @param event - The event name to subscribe to\n   * @param handler - The callback function to execute when the event is dispatched\n   * @param opts - Optional configuration\n   * @param opts.notify - If true and the event was previously dispatched, handler will be called immediately with the latest payload\n   * @returns void\n   */\n  on: <Event extends keyof Events>(\n    event: Event,\n    handler: EventHandler<Events, Event>,\n    opts?: { notify?: boolean },\n  ) => void;\n\n  /**\n   * Subscribe to an event with pre-dispatch priority\n   * Pre-dispatch handlers are called before regular event handlers when an event is dispatched\n   *\n   * @param event - The event name to subscribe to\n   * @param handler - The callback function to execute when the event is dispatched\n   * @returns void\n   */\n  prioritizedOn: <Event extends keyof Events>(event: Event, handler: EventHandler<Events, Event>) => void;\n\n  /**\n   * Publish an event with a payload\n   * Triggers all registered handlers for the event\n   *\n   * @param event - The event name to publish\n   * @param payload - The data to pass to event handlers\n   * @returns void\n   */\n  emit: <Event extends keyof Events>(event: Event, payload: Events[Event]) => void;\n\n  /**\n   * Unsubscribe from an event\n   *\n   * @param event - The event name to unsubscribe from\n   * @param handler - Optional specific handler to remove. If omitted, all handlers for the event are removed\n   * @returns void\n   */\n  off: <Event extends keyof Events>(event: Event, handler?: EventHandler<Events, Event>) => void;\n\n  /**\n   * Unsubscribe from a pre-dispatch event\n   *\n   * @param event - The event name to unsubscribe from\n   * @param handler - Optional specific handler to remove. If omitted, all pre-dispatch handlers for the event are removed\n   * @returns void\n   */\n  prioritizedOff: <Event extends keyof Events>(event: Event, handler?: EventHandler<Events, Event>) => void;\n\n  /**\n   * Internal utilities for the event bus\n   */\n  internal: {\n    /**\n     * Retrieve all listeners for a specific event\n     *\n     * @param event - The event name to get listeners for\n     * @returns Array of handler functions\n     */\n    retrieveListeners: <Event extends keyof Events>(event: Event) => Array<(...args: any[]) => void>;\n  };\n};\n\n/**\n * @internal\n */\ntype InternalOn = <Events extends Record<string, unknown>, Event extends keyof Events>(\n  eventToHandlersMap: Map<keyof Events, Array<(...args: any[]) => void>>,\n  latestPayloadMap: Map<keyof Events, any>,\n  event: Event,\n  handler: EventHandler<Events, Event>,\n  opts?: { notify?: boolean },\n) => void;\n\n/**\n * @internal\n */\ntype InternalOff = <Events extends Record<string, unknown>, Event extends keyof Events>(\n  eventToHandlersMap: Map<keyof Events, Array<(...args: any[]) => void>>,\n  event: Event,\n  handler?: EventHandler<Events, Event>,\n) => void;\n\n/**\n * @internal\n */\ntype InternalDispatch = <Events extends Record<string, unknown>, Event extends keyof Events>(\n  eventToHandlersMap: Map<keyof Events, Array<(...args: any[]) => void>>,\n  event: Event,\n  payload: Events[Event],\n) => void;\n\n/**\n * @internal\n */\nconst _on: InternalOn = (eventToHandlersMap, latestPayloadMap, event, handler, opts) => {\n  const { notify } = opts || {};\n  let handlers = eventToHandlersMap.get(event);\n\n  if (!handlers) {\n    handlers = [];\n    eventToHandlersMap.set(event, handlers);\n  }\n\n  handlers.push(handler);\n\n  if (notify && latestPayloadMap.has(event)) {\n    handler(latestPayloadMap.get(event));\n  }\n};\n\n/**\n * @internal\n */\nconst _dispatch: InternalDispatch = (eventToHandlersMap, event, payload) =>\n  (eventToHandlersMap.get(event) || []).map(h => h(payload));\n\n/**\n * @internal\n */\nconst _off: InternalOff = (eventToHandlersMap, event, handler) => {\n  const handlers = eventToHandlersMap.get(event);\n  if (handlers) {\n    if (handler) {\n      handlers.splice(handlers.indexOf(handler) >>> 0, 1);\n    } else {\n      eventToHandlersMap.set(event, []);\n    }\n  }\n};\n\n/**\n * A ES6/2015 compatible 300 byte event bus\n *\n * Creates a strongly-typed event bus that enables publish/subscribe communication between components.\n *\n * @template Events - A record type that maps event names to their payload types\n * @returns An EventBus instance with the following methods:\n * - `on`: Subscribe to an event\n * - `onPreDispatch`: Subscribe to an event, triggered before regular subscribers\n * - `emit`: Publish an event with payload\n * - `off`: Unsubscribe from an event\n * - `offPreDispatch`: Unsubscribe from a pre-dispatch event\n *\n * @example\n * // Define event types\n * const eventBus = createEventBus<{\n *   'user-login': { userId: string; timestamp: number };\n *   'data-updated': { records: any[] };\n *   'error': Error;\n * }>();\n *\n * // Subscribe to events\n * eventBus.on('user-login', ({ userId, timestamp }) => {\n *   console.log(`User ${userId} logged in at ${timestamp}`);\n * });\n *\n * // Subscribe with immediate notification if event was already dispatched\n * eventBus.on('user-login', (payload) => {\n *   // This will be called immediately if 'user-login' was previously dispatched\n * }, { notify: true });\n *\n * // Publish an event\n * eventBus.emit('user-login', { userId: 'abc123', timestamp: Date.now() });\n *\n * // Unsubscribe from event\n * const handler = (payload) => console.log(payload);\n * eventBus.on('error', handler);\n * // Later...\n * eventBus.off('error', handler);\n *\n * // Unsubscribe all handlers for an event\n * eventBus.off('data-updated');\n */\nexport const createEventBus = <Events extends Record<string, unknown>>(): EventBus<Events> => {\n  const eventToHandlersMap = new Map<keyof Events, Array<(...args: any[]) => void>>();\n  const latestPayloadMap = new Map<keyof Events, any>();\n  const eventToPredispatchHandlersMap = new Map<keyof Events, Array<(...args: any[]) => void>>();\n\n  const emit: EventBus<Events>['emit'] = (event, payload) => {\n    latestPayloadMap.set(event, payload);\n    _dispatch(eventToPredispatchHandlersMap, event, payload);\n    _dispatch(eventToHandlersMap, event, payload);\n  };\n\n  return {\n    // Subscribe to an event\n    on: (...args) => _on(eventToHandlersMap, latestPayloadMap, ...args),\n    // Subscribe to an event with priority\n    // Registered handlers with `prioritizedOn` will be called before handlers registered with `on`\n    prioritizedOn: (...args) => _on(eventToPredispatchHandlersMap, latestPayloadMap, ...args),\n    // Dispatch an event\n    emit,\n    // Unsubscribe from an event\n    off: (...args) => _off(eventToHandlersMap, ...args),\n    // Unsubscribe from an event with priority\n    // Unsubscribes handlers only registered with `prioritizedOn`\n    prioritizedOff: (...args) => _off(eventToPredispatchHandlersMap, ...args),\n\n    // Internal utilities\n    internal: {\n      retrieveListeners: event => eventToHandlersMap.get(event) || [],\n    },\n  };\n};\n"],"mappings":";AA6GA,IAAMA,GAAA,GAAkBA,CAACC,kBAAA,EAAoBC,gBAAA,EAAkBC,KAAA,EAAOC,OAAA,EAASC,IAAA,KAAS;EACtF,MAAM;IAAEC;EAAO,IAAID,IAAA,IAAQ,CAAC;EAC5B,IAAIE,QAAA,GAAWN,kBAAA,CAAmBO,GAAA,CAAIL,KAAK;EAE3C,IAAI,CAACI,QAAA,EAAU;IACbA,QAAA,GAAW,EAAC;IACZN,kBAAA,CAAmBQ,GAAA,CAAIN,KAAA,EAAOI,QAAQ;EACxC;EAEAA,QAAA,CAASG,IAAA,CAAKN,OAAO;EAErB,IAAIE,MAAA,IAAUJ,gBAAA,CAAiBS,GAAA,CAAIR,KAAK,GAAG;IACzCC,OAAA,CAAQF,gBAAA,CAAiBM,GAAA,CAAIL,KAAK,CAAC;EACrC;AACF;AAKA,IAAMS,SAAA,GAA8BA,CAACX,kBAAA,EAAoBE,KAAA,EAAOU,OAAA,MAC7DZ,kBAAA,CAAmBO,GAAA,CAAIL,KAAK,KAAK,EAAC,EAAGW,GAAA,CAAIC,CAAA,IAAKA,CAAA,CAAEF,OAAO,CAAC;AAK3D,IAAMG,IAAA,GAAoBA,CAACf,kBAAA,EAAoBE,KAAA,EAAOC,OAAA,KAAY;EAChE,MAAMG,QAAA,GAAWN,kBAAA,CAAmBO,GAAA,CAAIL,KAAK;EAC7C,IAAII,QAAA,EAAU;IACZ,IAAIH,OAAA,EAAS;MACXG,QAAA,CAASU,MAAA,CAAOV,QAAA,CAASW,OAAA,CAAQd,OAAO,MAAM,GAAG,CAAC;IACpD,OAAO;MACLH,kBAAA,CAAmBQ,GAAA,CAAIN,KAAA,EAAO,EAAE;IAClC;EACF;AACF;AA6CO,IAAMgB,cAAA,GAAiBA,CAAA,KAAgE;EAC5F,MAAMlB,kBAAA,GAAqB,mBAAImB,GAAA,CAAmD;EAClF,MAAMlB,gBAAA,GAAmB,mBAAIkB,GAAA,CAAuB;EACpD,MAAMC,6BAAA,GAAgC,mBAAID,GAAA,CAAmD;EAE7F,MAAME,IAAA,GAAiCA,CAACnB,KAAA,EAAOU,OAAA,KAAY;IACzDX,gBAAA,CAAiBO,GAAA,CAAIN,KAAA,EAAOU,OAAO;IACnCD,SAAA,CAAUS,6BAAA,EAA+BlB,KAAA,EAAOU,OAAO;IACvDD,SAAA,CAAUX,kBAAA,EAAoBE,KAAA,EAAOU,OAAO;EAC9C;EAEA,OAAO;IAAA;IAELU,EAAA,EAAIA,CAAA,GAAIC,IAAA,KAASxB,GAAA,CAAIC,kBAAA,EAAoBC,gBAAA,EAAkB,GAAGsB,IAAI;IAAA;IAAA;IAGlEC,aAAA,EAAeA,CAAA,GAAID,IAAA,KAASxB,GAAA,CAAIqB,6BAAA,EAA+BnB,gBAAA,EAAkB,GAAGsB,IAAI;IAAA;IAExFF,IAAA;IAAA;IAEAI,GAAA,EAAKA,CAAA,GAAIF,IAAA,KAASR,IAAA,CAAKf,kBAAA,EAAoB,GAAGuB,IAAI;IAAA;IAAA;IAGlDG,cAAA,EAAgBA,CAAA,GAAIH,IAAA,KAASR,IAAA,CAAKK,6BAAA,EAA+B,GAAGG,IAAI;IAAA;IAGxEI,QAAA,EAAU;MACRC,iBAAA,EAAmB1B,KAAA,IAASF,kBAAA,CAAmBO,GAAA,CAAIL,KAAK,KAAK;IAC/D;EACF;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}