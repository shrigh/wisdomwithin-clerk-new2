{"ast":null,"code":"// src/retry.ts\nvar defaultOptions = {\n  initialDelay: 125,\n  maxDelayBetweenRetries: 0,\n  factor: 2,\n  shouldRetry: (_, iteration) => iteration < 5,\n  retryImmediately: false,\n  jitter: true\n};\nvar RETRY_IMMEDIATELY_DELAY = 100;\nvar sleep = async ms => new Promise(s => setTimeout(s, ms));\nvar applyJitter = (delay, jitter) => {\n  return jitter ? delay * (1 + Math.random()) : delay;\n};\nvar createExponentialDelayAsyncFn = opts => {\n  let timesCalled = 0;\n  const calculateDelayInMs = () => {\n    const constant = opts.initialDelay;\n    const base = opts.factor;\n    let delay = constant * Math.pow(base, timesCalled);\n    delay = applyJitter(delay, opts.jitter);\n    return Math.min(opts.maxDelayBetweenRetries || delay, delay);\n  };\n  return async () => {\n    await sleep(calculateDelayInMs());\n    timesCalled++;\n  };\n};\nvar retry = async (callback, options = {}) => {\n  let iterations = 0;\n  const {\n    shouldRetry,\n    initialDelay,\n    maxDelayBetweenRetries,\n    factor,\n    retryImmediately,\n    jitter\n  } = {\n    ...defaultOptions,\n    ...options\n  };\n  const delay = createExponentialDelayAsyncFn({\n    initialDelay,\n    maxDelayBetweenRetries,\n    factor,\n    jitter\n  });\n  while (true) {\n    try {\n      return await callback();\n    } catch (e) {\n      iterations++;\n      if (!shouldRetry(e, iterations)) {\n        throw e;\n      }\n      if (retryImmediately && iterations === 1) {\n        await sleep(applyJitter(RETRY_IMMEDIATELY_DELAY, jitter));\n      } else {\n        await delay();\n      }\n    }\n  }\n};\nexport { retry };","map":{"version":3,"names":["defaultOptions","initialDelay","maxDelayBetweenRetries","factor","shouldRetry","_","iteration","retryImmediately","jitter","RETRY_IMMEDIATELY_DELAY","sleep","ms","Promise","s","setTimeout","applyJitter","delay","Math","random","createExponentialDelayAsyncFn","opts","timesCalled","calculateDelayInMs","constant","base","pow","min","retry","callback","options","iterations","e"],"sources":["D:\\Ripple Media Office work\\React\\wisdomwithin-clerk-new\\node_modules\\@clerk\\shared\\src\\retry.ts"],"sourcesContent":["type Milliseconds = number;\n\ntype RetryOptions = Partial<{\n  /**\n   * The initial delay before the first retry.\n   * @default 125\n   */\n  initialDelay: Milliseconds;\n  /**\n   * The maximum delay between retries.\n   * The delay between retries will never exceed this value.\n   * If set to 0, the delay will increase indefinitely.\n   * @default 0\n   */\n  maxDelayBetweenRetries: Milliseconds;\n  /**\n   * The multiplier for the exponential backoff.\n   * @default 2\n   */\n  factor: number;\n  /**\n   * A function to determine if the operation should be retried.\n   * The callback accepts the error that was thrown and the number of iterations.\n   * The iterations variable references the number of retries AFTER attempt\n   * that caused the error and starts at 1 (as in, this is the 1st, 2nd, nth retry).\n   * @default (error, iterations) => iterations < 5\n   */\n  shouldRetry: (error: unknown, iterations: number) => boolean;\n  /**\n   * Controls whether the helper should retry the operation immediately once before applying exponential backoff.\n   * The delay for the immediate retry is 100ms.\n   * @default false\n   */\n  retryImmediately: boolean;\n  /**\n   * If true, the intervals will be multiplied by a factor in the range of [1,2].\n   * @default true\n   */\n  jitter: boolean;\n}>;\n\nconst defaultOptions: Required<RetryOptions> = {\n  initialDelay: 125,\n  maxDelayBetweenRetries: 0,\n  factor: 2,\n  shouldRetry: (_: unknown, iteration: number) => iteration < 5,\n  retryImmediately: false,\n  jitter: true,\n};\n\nconst RETRY_IMMEDIATELY_DELAY = 100;\n\nconst sleep = async (ms: Milliseconds) => new Promise(s => setTimeout(s, ms));\n\nconst applyJitter = (delay: Milliseconds, jitter: boolean) => {\n  return jitter ? delay * (1 + Math.random()) : delay;\n};\n\nconst createExponentialDelayAsyncFn = (\n  opts: Required<Pick<RetryOptions, 'initialDelay' | 'maxDelayBetweenRetries' | 'factor' | 'jitter'>>,\n) => {\n  let timesCalled = 0;\n\n  const calculateDelayInMs = () => {\n    const constant = opts.initialDelay;\n    const base = opts.factor;\n    let delay = constant * Math.pow(base, timesCalled);\n    delay = applyJitter(delay, opts.jitter);\n    return Math.min(opts.maxDelayBetweenRetries || delay, delay);\n  };\n\n  return async (): Promise<void> => {\n    await sleep(calculateDelayInMs());\n    timesCalled++;\n  };\n};\n\n/**\n * Retries a callback until it succeeds or the shouldRetry function returns false.\n * See {@link RetryOptions} for the available options.\n */\nexport const retry = async <T>(callback: () => T | Promise<T>, options: RetryOptions = {}): Promise<T> => {\n  let iterations = 0;\n  const { shouldRetry, initialDelay, maxDelayBetweenRetries, factor, retryImmediately, jitter } = {\n    ...defaultOptions,\n    ...options,\n  };\n\n  const delay = createExponentialDelayAsyncFn({\n    initialDelay,\n    maxDelayBetweenRetries,\n    factor,\n    jitter,\n  });\n\n  while (true) {\n    try {\n      return await callback();\n    } catch (e) {\n      iterations++;\n      if (!shouldRetry(e, iterations)) {\n        throw e;\n      }\n      if (retryImmediately && iterations === 1) {\n        await sleep(applyJitter(RETRY_IMMEDIATELY_DELAY, jitter));\n      } else {\n        await delay();\n      }\n    }\n  }\n};\n"],"mappings":";AAyCA,IAAMA,cAAA,GAAyC;EAC7CC,YAAA,EAAc;EACdC,sBAAA,EAAwB;EACxBC,MAAA,EAAQ;EACRC,WAAA,EAAaA,CAACC,CAAA,EAAYC,SAAA,KAAsBA,SAAA,GAAY;EAC5DC,gBAAA,EAAkB;EAClBC,MAAA,EAAQ;AACV;AAEA,IAAMC,uBAAA,GAA0B;AAEhC,IAAMC,KAAA,GAAQ,MAAOC,EAAA,IAAqB,IAAIC,OAAA,CAAQC,CAAA,IAAKC,UAAA,CAAWD,CAAA,EAAGF,EAAE,CAAC;AAE5E,IAAMI,WAAA,GAAcA,CAACC,KAAA,EAAqBR,MAAA,KAAoB;EAC5D,OAAOA,MAAA,GAASQ,KAAA,IAAS,IAAIC,IAAA,CAAKC,MAAA,CAAO,KAAKF,KAAA;AAChD;AAEA,IAAMG,6BAAA,GACJC,IAAA,IACG;EACH,IAAIC,WAAA,GAAc;EAElB,MAAMC,kBAAA,GAAqBA,CAAA,KAAM;IAC/B,MAAMC,QAAA,GAAWH,IAAA,CAAKnB,YAAA;IACtB,MAAMuB,IAAA,GAAOJ,IAAA,CAAKjB,MAAA;IAClB,IAAIa,KAAA,GAAQO,QAAA,GAAWN,IAAA,CAAKQ,GAAA,CAAID,IAAA,EAAMH,WAAW;IACjDL,KAAA,GAAQD,WAAA,CAAYC,KAAA,EAAOI,IAAA,CAAKZ,MAAM;IACtC,OAAOS,IAAA,CAAKS,GAAA,CAAIN,IAAA,CAAKlB,sBAAA,IAA0Bc,KAAA,EAAOA,KAAK;EAC7D;EAEA,OAAO,YAA2B;IAChC,MAAMN,KAAA,CAAMY,kBAAA,CAAmB,CAAC;IAChCD,WAAA;EACF;AACF;AAMO,IAAMM,KAAA,GAAQ,MAAAA,CAAUC,QAAA,EAAgCC,OAAA,GAAwB,CAAC,MAAkB;EACxG,IAAIC,UAAA,GAAa;EACjB,MAAM;IAAE1B,WAAA;IAAaH,YAAA;IAAcC,sBAAA;IAAwBC,MAAA;IAAQI,gBAAA;IAAkBC;EAAO,IAAI;IAC9F,GAAGR,cAAA;IACH,GAAG6B;EACL;EAEA,MAAMb,KAAA,GAAQG,6BAAA,CAA8B;IAC1ClB,YAAA;IACAC,sBAAA;IACAC,MAAA;IACAK;EACF,CAAC;EAED,OAAO,MAAM;IACX,IAAI;MACF,OAAO,MAAMoB,QAAA,CAAS;IACxB,SAASG,CAAA,EAAG;MACVD,UAAA;MACA,IAAI,CAAC1B,WAAA,CAAY2B,CAAA,EAAGD,UAAU,GAAG;QAC/B,MAAMC,CAAA;MACR;MACA,IAAIxB,gBAAA,IAAoBuB,UAAA,KAAe,GAAG;QACxC,MAAMpB,KAAA,CAAMK,WAAA,CAAYN,uBAAA,EAAyBD,MAAM,CAAC;MAC1D,OAAO;QACL,MAAMQ,KAAA,CAAM;MACd;IACF;EACF;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}